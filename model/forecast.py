import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# time series features
from statsmodels.tsa.deterministic import CalendarFourier, DeterministicProcess

# regression models
from xgboost import XGBRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, mean_absolute_percentage_error

sns.set_style("whitegrid")
sns.set_theme()

class Model:
    def __init__(self, name):
        self.name = name
        
    def fit(self, X_train, y_train):
        """
            Train the model with the data given
        """
        self.y_train = y_train
        self.model.fit(X_train, y_train)
        print("Training completed")
        
    def score(self, X_test, y_test):
        """
            Returns model's score
        """
        print("Coefficient of Determination (R2):", str(round(self.model.score(X_test, y_test) * 100, 2)) + "%")
        
    def forecast(self, X_test):
        """
            Returns forecasted period (Receive time series generated by DeterministicProcess object)
        """
        return self.model.predict(X_test)
    
    def evaluate(self, X_test, y_test, show_eval_plot=False):
        """
            Evaluate the model's performance
        """
        try:
            y_pred = self.predict(X_test)
            rmse = mean_squared_error(y_pred, y_test, squared=False)
            sample_range = self.y_train.max() - self.y_train.min()
            normalized_rmse = ((rmse) / sample_range)
            
            ### print evaluation metrics
            self.score(X_test, y_test)
            print("Mean Absolute Error:", mean_absolute_error(y_pred, y_test))
            print("Mean Absolute Percentage Error:", mean_absolute_percentage_error(y_pred, y_test))
            print("RMSE:", rmse)
            print("Normalized RMSE:", normalized_rmse)

            ### plot the graph
            X_labels = X_test.index.to_timestamp(freq='D')
            plt.figure(figsize=(14, 8))
            plt.title(f"{self.name} Model's Forecasted VS Actual Values")
            ax = sns.lineplot(x=X_labels, y=y_test, label='actual-values', alpha=0.5, marker='o')
            ax = sns.lineplot(ax=ax, x=X_labels, y=y_pred, label='forecasted', marker='o')

            if show_eval_plot:
                plt.show()
            
        except AttributeError:
            print("Please train your model first before evaluating!")
            
    def get_model(self):
        return self.model
            
class XGBModel(Model):
    def __init__(self, name, **kwargs):
        super().__init__(name)
        self.model = XGBRegressor(**kwargs)
        
class RFModel(Model):
    def __init__(self, name, **kwargs):
        super().__init__(name)
        self.model = RandomForestRegressor(**kwargs)


def create_xgboost_model():
    pass

def create_rf_model(name):
    """
        Returns a RFModel object
    """
    rfmodel = RFModel(name, n_estimators=300, random_state=42)

    return rfmodel
